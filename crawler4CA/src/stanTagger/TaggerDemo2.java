package stanTagger;


import java.io.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Properties;
import java.util.Scanner;
import java.util.Set;

import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.ling.Sentence;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.ling.HasWord;
import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.neural.rnn.RNNCoreAnnotations;
import edu.stanford.nlp.pipeline.Annotation;
import edu.stanford.nlp.pipeline.StanfordCoreNLP;
import edu.stanford.nlp.process.CoreLabelTokenFactory;
import edu.stanford.nlp.process.DocumentPreprocessor;
import edu.stanford.nlp.process.PTBTokenizer;
import edu.stanford.nlp.process.TokenizerFactory;
import edu.stanford.nlp.sentiment.SentimentCoreAnnotations;
import edu.stanford.nlp.tagger.maxent.MaxentTagger;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.util.CoreMap;

/** This demo shows user-provided sentences (i.e., {@code List<HasWord>})
 *  being tagged by the tagger. The sentences are generated by direct use
 *  of the DocumentPreprocessor class.
 *
 *  @author Christopher Manning
 */
class TaggerDemo2 {

  private TaggerDemo2() {}
  



	public static Set<String> loadDictionary(String fileName) throws IOException {
	    Set<String> words = new HashSet<String>();
	    File file = new File(fileName+".txt");
	    BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file)));
	    Scanner sc = new Scanner(br);
	    while (sc.hasNext()) {
	        words.add(sc.next());
	    }
	    br.close();
	    return words;
	}

  public static void main(String[] args) throws Exception {
//    if (args.length != 2) {
//      System.err.println("usage: java TaggerDemo2 modelFile fileToTag");
//      return;
//    }
	  
	long positiveCount = 0;
	long negativeCount = 0;
	Set<String> positive = loadDictionary("positivewordsdictionary");
    Set<String> negative = loadDictionary("negativewordsdictionary");
    List<String> classification = new ArrayList<String>(); 
	int i = 0;
	int j = 0;
	String line = "";
	String stanClassSentiment = "";
	String classified = "";
    
    MaxentTagger tagger = new MaxentTagger("/Users/lelong/Documents/workspace/consolidatedCrawler/crawler4CA/taggers/english-left3words-distsim.tagger");
    TokenizerFactory<CoreLabel> ptbTokenizerFactory = PTBTokenizer.factory(new CoreLabelTokenFactory(),
									   "untokenizable=noneKeep");
    BufferedReader r = new BufferedReader(new InputStreamReader(new FileInputStream("/Users/lelong/Documents/workspace/consolidatedCrawler/crawler4CA/checkFile.txt"), "utf-8"));
    PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out, "utf-8"));
    DocumentPreprocessor documentPreprocessor = new DocumentPreprocessor(r);
    documentPreprocessor.setTokenizerFactory(ptbTokenizerFactory);
    for (List<HasWord> sentence : documentPreprocessor) {
    	pw.println("\n\n");
        List<TaggedWord> taggedSent = tagger.tagSentence(sentence);
        for (TaggedWord tw : taggedSent) {
          if (tw.tag().startsWith("JJ")) {
        	  if (positive.contains(tw.word().toLowerCase())) {
  	            	System.out.println("Found positive "+positiveCount+":"+tw.word());
  	            	positiveCount++;
  	        	}
  	        	if (negative.contains(tw.word().toLowerCase())) {
  	        		System.out.println("Found negative "+negativeCount+":"+tw.word());
  	        		negativeCount++;
  	        	}
            pw.println(tw.word());
          }
        }
        
        
        if(positiveCount>negativeCount){
        	classification.add("positive");
        	positiveCount=0;
        	negativeCount=0;
        }
        else if(negativeCount>positiveCount){
        	classification.add("negative");
        	positiveCount=0;
        	negativeCount=0;
        }
        else{
        	classification.add("neutral");
        	positiveCount=0;
        	negativeCount=0;
        }
    }
    pw.println(classification);
    pw.println(positiveCount);
    pw.println(negativeCount);
    pw.close();
    
    // Stanford Sentiment Analyser:
    BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("/Users/lelong/Documents/workspace/consolidatedCrawler/crawler4CA/checkFile.txt"), "utf-8"));
    while (br.ready()){
    	line = br.readLine();	
    	stanClassSentiment = findSentiment(line); 
    	if(stanClassSentiment.equals("negative")){
    		if(stanClassSentiment.equals(classification.get(j))){
        		//do nothing
        	}
    		else{
    			stanClassSentiment = classification.get(j);
    		}
    	}
    	
    	if(j==0){
    	classified =  line + " -- "+stanClassSentiment +"<br>\n";
    	}
    	else{
    		classified = classified + line + " -- "+stanClassSentiment +"<br>\n"; 
    	}
    	j++;
    }
    
    File f = new File("/Users/lelong/Documents/workspace/consolidatedCrawler/crawler4CA/sentiment.txt");
	Boolean flag = false;
	if(f.exists()){
		f.delete();
		flag = true;
		System.out.println("flag : "+flag);
	}
	else{
		System.out.println("File not found to delete");
	}
    
    BufferedWriter bw = new BufferedWriter(new FileWriter("/Users/lelong/Documents/workspace/consolidatedCrawler/crawler4CA/sentiment.txt"));
    bw.write(classified);
    bw.close();
    
  }
  
  public static String findSentiment(String line) {

      Properties props = new Properties();
      props.setProperty("annotators", "tokenize, ssplit, parse, sentiment");
      StanfordCoreNLP pipeline = new StanfordCoreNLP(props);
      int mainSentiment = 0;
      if (line != null && line.length() > 0) {
          int longest = 0;
          Annotation annotation = pipeline.process(line);
          for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {
              Tree tree = sentence.get(SentimentCoreAnnotations.AnnotatedTree.class);
              int sentiment = RNNCoreAnnotations.getPredictedClass(tree);
              String partText = sentence.toString();
              if (partText.length() > longest) {
                  mainSentiment = sentiment;
                  longest = partText.length();
              }

          }
      }
      if (mainSentiment > 4 || mainSentiment < 0) {
          return null;
      }
      String sentiValue = toCss(mainSentiment);
      return sentiValue;

  }

  private static String toCss(int sentiment) {
      switch (sentiment) {
      case 0:
          return "very negative";
      case 1:
          return "negative";
      case 2:
          return "neutral";
      case 3:
          return "postive";
      case 4:
          return "very positive";
      default:
          return "";
      }
  }
  

}
